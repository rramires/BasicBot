/*
ATENÇÃO: 
Esse bot é só um exemplo para facilitar o aprendizado de acesso a API!
A responsabilidade é totalmente sua! É algo muito cru pra ser usado em produção com o objetivo de obter lucros.
Implemente suas estratégias por SUA CONTA e RISCO!
Não venha perturbar depois esperando resultado ou alegando prejuízo se usado em produção. 
*/


1 - Inicir projeto
npm init -y


2 - Instalar as dependências - Axios cliente http, Dotenv carregar as configurações
npm install axios dotenv 


3 - Criar um arquivo .env
touch .env


4 - Adicionar no .env as constantes
API_URL=https://api.binance.com/api
API_VERSION = v3
API_KEY=
SECRET_KEY=
CRAWLER_INTERVAL=2000
PROFITABILITY=1.05

// Para ver os limites, teste no browser
https://api.binance.com/api/v3/exchangeInfo


5 - Verifique se o .env e node_modules estão no 
.gitignore


6 - Crie o arquivo da app, index.js e adicione
setInterval(() => {
    console.log('Chamou a API !')
}, process.env.CRAWLER_INTERVAL)


7 - Configure o dotenv no package.json, em scripts adicione
"start": "node -r dotenv/config index",


8 - Teste
npm start

Deve imprimir no console 
"Chamou a API !"

------------------------------


9 - Crie um aquivo api.js que servirá de wrapper
// imports
const axios = require('axios')
const querystring = require('querystring')

/**
 * Metodo interno que monta e faz as chamadas
 * 
 * @param path - Consulta desejada na API
 * @param data - Dados que serão convertidos no formato querystring
 * @param method GET ou POST
 * @returns json
 */
const publicCall = async (path, data, method = 'GET') => {
    try{
        // monta a query
        const query = data ? `?${querystring.encode(data)}` : ''

        // monta a url
        const url = `${process.env.API_URL}/${process.env.API_VERSION}/${path}${query}`
        //console.log('url: ', url)

        // faz a chamada
        const result = await axios({
            method,
            url
        })
        return result.data
    }
    catch(err){
        console.log(err)
    }
}


/**
 * Metodo de teste, que retora o horario do servidor
 * 
 * @returns json
 */
const time = async () => {
    return publicCall('time')
}

// exports
module.exports = {
    time
}


10 - Modifique o index.js para chamar a API
// imports
const api = require('./api')

setInterval(async () => {
    // faz a chamada
    console.log('Chamou a API :',  await api.time())
}, process.env.CRAWLER_INTERVAL)


11 - Teste
npm start
// Deve imprimir o timestamp do servidor da Binance, ex:
Chamou a API : { serverTime: 1633299402667 }

------------------------------


12 - Teste no browser o Depht
https://api.binance.com/api/v3/depth?symbol=BTCBRL&limit=5

12 - Criando o monitoramento do mercado. Em api.js adicione depois do metodo time
/**
 * Retorna infos do book de um par de moedas (symbol)
 * 
 * @param symbol Par de moedas, ex BTCUSDT, LTCBTC, etc
 * @param limit Quantidade de ordens no book - Minimo 5
 * @returns 
 */
const depth = async (symbol = 'BTCUSDT', limit = 5) => {
    return publicCall('depth', {
        symbol, 
        limit
    })
}

// adicione no exports
module.exports = {
    time,
    depth
}


13 - Modifique a app, adicionando em index.js
setInterval(async () => {
    // faz a chamada
    // console.log('Chamou a API :',  await api.time())
    console.log('Depth :',  await api.depth())
}, process.env.CRAWLER_INTERVAL)


14 - Teste
npm start
// Deve imprimir 5 linhas do book, ex:
Depth : {
  lastUpdateId: 14067475097,
  bids: [
    [ '47969.90000000', '0.05381000' ],
    [ '47966.92000000', '0.00022000' ],
    [ '47966.53000000', '0.29880000' ],
    [ '47966.24000000', '0.80145000' ],
    [ '47965.55000000', '0.04457000' ]
  ],
  asks: [
    [ '47969.91000000', '1.02805000' ],
    [ '47969.95000000', '0.00237000' ],
    [ '47971.23000000', '0.67001000' ],
    [ '47971.24000000', '0.46064000' ],
    [ '47972.21000000', '0.02200000' ]
  ]
}


15 - Percebendo que é uma matriz, vamos filtrar
setInterval(async () => {
    // faz a chamada
    // console.log('Chamou a API :',  await api.time())
    // console.log('Depth :',  await api.depth())
    const result = await api.depth()
    console.log('Highest Buy: ',  result.bids[0][0])
    console.log('Lowest Sell: ',  result.asks[0][0])
}, process.env.CRAWLER_INTERVAL)


16 - Teste novamente
npm start
// Deve imprimir 2 linhas do book, ex:
Highest Buy:  47955.62000000
Lowest Sell:  47955.63000000

------------------------------


17 - Criar o acesso à API Testnet da Binance.
Faça login no GitHub

Vá em 
testnet.binance.vision

Clique no início da página em
Log In with GitHub

Clique em Authorize binance-exchange

Clique em Generate HMAC_SHA256 Key
Digite um nome e salve as as chaves em algum local seguro, pois senão terá que criar outras
API Key: XXXX...
Secret Key: YYYY...


18 - Adicione as chaves geradas no .env
API_KEY=XXXX...
SECRET_KEY=YYYY...

Mude a URL para testnet
API_URL=https://testnet.binance.vision/api 

Aumente o tempo para 5 segundos
CRAWLER_INTERVAL=5000

Adicione mais uma configuração para definir o symbol (par de moedas)
SYMBOL=BTCUSDT

Tudo fica assim:
API_URL=https://testnet.binance.vision/api 
API_VERSION = v3
API_KEY=XXXX...
SECRET_KEY=YYYY...
CRAWLER_INTERVAL=5000
PROFITABILITY=1.05
SYMBOL=BTCUSDT

19 - Teste novamente
npm start
// lembre-se que agora são valores fake
Highest Buy:  48780.83000000
Lowest Sell:  48783.51000000

// Obs: a API de teste forneçe uma carteira com pares e valores fake que mudam de tempo em tempo

------------------------------


20 - Pegando as informações da Exchange. Em api.js adicione o metodo
/**
 * Retorna as informações da Exchange
 * 
 * @returns json
 */
const exchangeInfo = async () => {
    return publicCall('exchangeInfo')
}

Adicione no Exports
module.exports = {
    time,
    depth,
    exchangeInfo
}


21 - Adicione na app, index.js para testar
setInterval(async () => {
    // faz a chamada
    // console.log('Chamou a API :',  await api.time())
    // console.log('Depth :',  await api.depth())
    /*
    const result = await api.depth()
    console.log('Highest Buy: ',  result.bids[0][0])
    console.log('Lowest Sell: ',  result.asks[0][0])
    */
   console.log('ExchangeInfo :',  await api.exchangeInfo())
}, process.env.CRAWLER_INTERVAL)


22 - Teste 
npm start
// Retorna um json enorme
ExchangeInfo : {
  timezone: 'UTC',
  serverTime: 1633366741436, etc...


23 - Observe nesse json, mais abaixo em "symbols" os pares que estão sendo operados(TRADING) no momento, ex:
symbol: 'BTCUSDT',
status: 'TRADING'

symbol: 'BNBUSDT',
status: 'TRADING'
etc...

// Outra informação, caso não saiba
Bids = Ordens de compra
Asks = Ordens de venda


24 - Adicione um deles ao .env No meu caso, resolvi manter BTCUSDT pois está ativo (TRADING)
SYMBOL=BTCUSDT


25 - Na app, index.js vamos pegar o symbol do .env
No início adicione
const api = require('./api')
const symbol = process.env.SYMBOL

E adicione na chamada ao depth
setInterval(async () => {
    // faz a chamada
    //console.log('Chamou a API :',  await api.time())
    //console.log('ExchangeInfo :',  await api.exchangeInfo())
    const result = await api.depth(symbol)
    console.log('Symbol: ',  symbol)
    console.log('Highest Buy: ',  result.bids[0][0])
    console.log('Lowest Sell: ',  result.asks[0][0])
}, process.env.CRAWLER_INTERVAL)


26 - Teste 
npm start
// Retorna
Symbol:  BTCUSDT
Highest Buy:  48408.46000000
Lowest Sell:  48420.23000000

------------------------------


27 - Filtro simples nos resultados. Na app, modifique para
setInterval(async () => {
    /*
    console.log('Chamou a API :',  await api.time())
    //console.log('ExchangeInfo :',  await api.exchangeInfo())
    */

    let buy = 0, sell = 0

    // faz a chamada no book
    const result = await api.depth(symbol)
    console.log('Symbol: ',  symbol)

    // filtra testando se não está vazio
    if(result.bids && result.bids.length){
        console.log('Highest Buy: ',  result.bids[0][0])
        buy = parseInt(result.bids[0][0])
    }
    if(result.asks && result.asks.length){
        console.log('Lowest Sell: ',  result.asks[0][0])
        sell = parseInt(result.asks[0][0])
    }

    // Implemente sua estratégia
    if(sell < 50000){
        console.log('Compre !!!')
    }
    else if(buy > 60000){
        console.log('Venda !!!')
    }
    else{
        console.log('Esperando o mercado sair do lugar...')
    }
}, process.env.CRAWLER_INTERVAL)

// Serve para ter uma noção do funcionamento


28 - Teste 
npm start
// Retorna algo como
Symbol:  BTCUSDT
Highest Buy:  49130.00000000
Lowest Sell:  49130.01000000
Compre !!!

------------------------------


29 - Criando uma chamada para a carteira, que deve ser "privada"
/*
Chamadas privadas requerem mais cuidado que as públicas, pois retornam dados sensíveis
Então precisam ser encriptadas
/*
Para isso vamos criar um novo método para chamadas privadas.

No início de api.js, adicione o pacote de criptografia e as infos da API do .env
const crypto = require('crypto')
const apiKey = process.env.API_KEY
const secretKey = process.env.SECRET_KEY
const apiURL = process.env.API_URL
const apiVersion = process.env.API_VERSION

Aproveite e em publicCall, substitua os process.env.XXX
const url = `${apiURL}/${apiVersion}/${path}${query}`
// teste para ver se está funcionando

Depois de publicCall, crie um novo método, para as chamadas privadas/encriptadas
/**
 * Metodo interno que monta e faz as chamadas privadas
 * 
 * @param path - Consulta desejada na API
 * @param data - Dados que serão convertidos no formato querystring
 * @param method GET ou POST
 * @returns json
 */
const privateCall = async (path, data = {}, method = 'GET') => {
    try{
        // pega o timestamp
        const timestamp = Date.now()
        // monta o hash/assinatura 
        const signature = crypto.createHmac('sha256', secretKey) // cria a assinatura
                                // incrementa os dados e o timestamp
                                .update(`${querystring.encode({...data, timestamp})}`) 
                                // define o formato de saída
                                .digest('hex')
        //console.log('Signature', signature)
        
        // gera o objeto de dados
        const newData = {...data, timestamp, signature}

        // monta a query
        const query = `?${querystring.encode(newData)}`

        // monta a url
        const url = `${apiURL}/${apiVersion}/${path}${query}`
        //console.log('url: ', url)

        // faz a chamada 
        // 'X-MBX-APIKEY', é um Header específico da Binance que tem que ter a API_KEY
        const result = await axios({
            method,
            url,
            headers: {
                'X-MBX-APIKEY': apiKey
            }
        })
        return result.data
    }
    catch(err){
        console.log(err)
    }
}


30 - Agora é possível criar um método para acessar a carteira
/**
 * Retorna as informações da Conta
 * 
 * @returns json
 */
 const accountInfo = async () => {
    return privateCall('account')
}

Não esqueça de exportar
module.exports = {
    time,
    depth,
    exchangeInfo,
    accountInfo
}


31 - Comente as outras chamadas na app, e adicione
console.log('Account Info: ',  await api.accountInfo())

Teste
npm start
// Deve retornar algo similar a
Account Info:  {
  makerCommission: 0, etc...

E o que nos interessa são os saldos:
balances: [
    { asset: 'BNB', free: '1000.00000000', locked: '0.00000000' }, etc...


32 - Filtrando
// faz a chamada na carteira
const account = await api.accountInfo()
// filtra para pegar as moedas
const coins = account.balances.filter(b => symbol.indexOf(b.asset) !== -1)
console.log('Posição da carteira: ', coins)

// Testando, deve retornar algo similar a
Posição da carteira: [
  { asset: 'BTC', free: '1.00000000', locked: '0.00000000' },
  { asset: 'USDT', free: '10000.00000000', locked: '0.00000000' }
]


33 - O código até aqui da app, index.js é:
// imports
const api = require('./api')
const symbol = process.env.SYMBOL

setInterval(async () => {
    /*
    console.log('Chamou a API :',  await api.time())
    //console.log('ExchangeInfo :',  await api.exchangeInfo())
    console.log('Account Info: ',  await api.accountInfo())
    */

    let buy = 0, sell = 0

    // faz a chamada no book
    const result = await api.depth(symbol)
    console.log('Symbol: ',  symbol)

    // filtra testando se não está vazio
    if(result.bids && result.bids.length){
        console.log('Highest Buy: ',  result.bids[0][0])
        buy = parseInt(result.bids[0][0])
    }
    if(result.asks && result.asks.length){
        console.log('Lowest Sell: ',  result.asks[0][0])
        sell = parseInt(result.asks[0][0])
    }

    // Implemente sua estratégia
    if(sell < 50000){
        console.log('Compre !!!')
    }
    else if(buy > 60000){
        console.log('Venda !!!')
    }
    else{
        console.log('Esperando o mercado sair do lugar...')
    }

    // fas a chamada na carteira
    const account = await api.accountInfo()
    // filtra para pegar as moedas
    const coins = account.balances.filter(b => symbol.indexOf(b.asset) !== -1)
    console.log('Posição da carteira: ', coins)

}, process.env.CRAWLER_INTERVAL)


34 - Testando
npm start
// Testando, deve retornar algo similar a
Symbol:  BTCUSDT
Highest Buy:  49258.87000000
Lowest Sell:  49258.88000000
Compre !!!
Posição da carteira:  [
  { asset: 'BTC', free: '1.00000000', locked: '0.00000000' },
  { asset: 'USDT', free: '10000.00000000', locked: '0.00000000' }
]

------------------------------


35 - Criando ordens. No api.js vamos adicionar mais um método
/**
 * 
 * @param symbol - Par de moedas, ex BTCUSDT
 * @param quantity - Quantidade
 * @param price - Preço
 * @param side - Qual book, BUY ou SELL
 * @param type - Tipo de ordem, LIMIT, MARKET, STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT, LIMIT_MAKER
 * @returns json
 */
const newOrder = async (symbol, quantity, price, side = 'BUY', type = 'MARKET') => {
    // monta o objeto de dados
    const data = {symbol, side, type, quantity}
    if(price){
        data.price = price
    }
    if(type === 'LIMIT'){
        data.timeInForce = 'GTC' // got til canceled - Ordem não expira
    }
    return privateCall('order', data, method = 'POST')
}

E exportar
module.exports = {
    time,
    depth,
    exchangeInfo,
    accountInfo,
    newOrder
}


36 - Agora vamos modificar a app, para validar algumas coisas e comprar
// Rode a app e verifique se o valor do IF é suficiente para comprar. ex if(sell < 51000)... tive que aumentar o valor hj.
// Depois a lógica de teste fica assim

// faz a chamada na carteira
const account = await api.accountInfo()
// filtra para pegar as moedas
const coins = account.balances.filter(b => symbol.indexOf(b.asset) !== -1)
console.log('Posição da carteira: ', coins)

// Implemente sua estratégia
if(sell < 51000){      
    // Verificando se tenho saldo 
    const saldo = parseInt(coins.find(c => c.asset === 'USDT').free)
    if(saldo > 10){
        console.log('Meu saldo é de: ', saldo)
        // Executa a ordem, comprando 0.01 BTC com USDT por exemplo
        // Não passamos p price, pois é uma ordem a mercado
        // ou seja, o menor preço no momento
        console.log('Compra: ', await api.newOrder(symbol, 0.01))
    }
    else{
        console.log('Saldo inferior a 10')
    }

}
else if(buy > 52500){
    console.log('Venda !!!')
}
else{
    console.log('Esperando o mercado sair do lugar...')
}


37 - Teste
npm start
// Se comprou deve retornar algo similar a
Compra:  {
  symbol: 'BTCUSDT',
  orderId: 1887135, etc...

// Perceba que foi completada 
status: 'FILLED'


38 - Comente a linha que executa a compra e teste novamente
//console.log('Compra: ', await api.newOrder(symbol, 0.01))

// Perceba a mudança dos saldos na carteira de USDT e BTC, ex:
// De
Posição da carteira:  [
  { asset: 'BTC', free: '1.00000000', locked: '0.00000000' },
  { asset: 'USDT', free: '10000.00000000', locked: '0.00000000' }
]
// Para
Posição da carteira:  [
  { asset: 'BTC', free: '1.01000000', locked: '0.00000000' },
  { asset: 'USDT', free: '9494.58249465', locked: '0.00000000' }
]


39 - Altere para
const buyOrder = await api.newOrder(symbol, 0.01)
console.log('BuyStatus: ', buyOrder.status, 'id: ', buyOrder.orderId)

// Execute novamente e teremos algo similar a
Symbol:  BTCUSDT
Highest Buy:  50883.25000000
Lowest Sell:  50883.26000000
Posição da carteira:  [
  { asset: 'BTC', free: '1.01000000', locked: '0.00000000' },
  { asset: 'USDT', free: '9494.58249465', locked: '0.00000000' }
]
Meu saldo é de:  9494
BuyStatus:  FILLED id:  1903693

------------------------------


40 - Criando uma ordem de venda
// Vamos criar uma ordem de venda imediatamente após comprar, 
// com o preço de compra multiplicado pelo PROFITABILITY no .env no caso +5%
No inicio adicione
const profit = process.env.PROFITABILITY

Depois comente a compra e adicione o código da venda
// Posicionar ordem de venda com algum lucro
const sellPrice = parseInt(sell * profit)
const sellOrder = await api.newOrder(symbol, 0.01, sellPrice, 'SELL', 'LIMIT')
console.log('SellStatus: ', sellOrder.status, 'id: ', sellOrder.orderId)

// Testando deve imprimir +-
SellStatus:  NEW id:  1931358

// A ordem foi posicionada, por isso o status é NEW
// Troque sellPrice por um valor bem menor para vender, ex comente
//const sellPrice = parseInt(sell * profit)
E adicione
const sellPrice = parseInt(buy * 0.9) 

Teste novamente, agora vem o status como FILLED e o array fills, com as ordens executadas
SellStatus:  FILLED id:  1939463

------------------------------


41 - Agora vamos refatorar algumas coisas. 
Se der algum erro, lembre-se:
400 - Passou algum parâmetro errado, ou fora de ordem 
401 - Chaves(API Key) com problema 
404 - URL Errada


a) Primeira cagada! troque todos os parseInt por parseFloat. Senão valores menores que 0, ex 0.334 viram Zero.
ctrl+h no VSCode 


b) Qdo enviamos mais de 8 casas decimais em algum parametro para a API, da erro.
   Mas depende da moeda. Eu acho que é no máximo 8 caracteres, no caso do BTC, são 2 casas decimais 
   Podemos depois implementar uma lógica melhor, por enquanto vamos consertar, com o .toFixed(2), ex
const sellPrice = parseFloat(sell * profit).toFixed(2)


c) Como definimos uma estratégia de exemplo de comprar e já posicionar 
  uma ordem de venda com algum percentual, perdeu o sentido o else if 
  de estratégia. Remova:
  else if(buy > 52500){
    console.log('Venda !!!')
  }


d) Vamos organizar e comentar o .env e adicionar mais a# Informações da API da Binance
# Informações da API da Binance
API_URL=https://testnet.binance.vision/api 
API_VERSION = v3
API_KEY=Jm0nju9adddWcjyozgD3gjotRZ2zn0nI1KWk3yJxmmwBYVcDHyqXPig2GPfjafKh
SECRET_KEY=ENbk16yCcD9S6gsi9HlUfokwFSN1v3pLZ0TGVQ46akyuQBFszHxP3UhFwEXrcUB2
#
# Intervalo em que são feitas as chamadas em milissegundos 
CRAWLER_INTERVAL=5000
#
# Ver pares de moedas e valores mínimos em binance.com/en/trade-rule
# Par de moedas
SYMBOL=BTCUSDT
# Qual moeda será acumulada. Ex acumular USDT num par BTCUSDT, Acumular BTC, num par BTCLTC
ACC_SYMBOL=USDT
# Saldo mínimo suficiente para fazer uma ordem, EX em USDT são 10 dólares
ACC_MIN_ORDER=10
# Quantidade a ser comprada e posta à venda por vez: EX 0.01BTC
QTY_ORDER=0.01
# Quantidade de casas decimais da moeda que quer vender, Ex BTC são 2
SYMBOL_DECIMAL=2
# Porcentagem adicionada ao valor de venda, ex 1.1 +10%, 1.05 +5%, etc 
PROFITABILITY=1.05
# Valor mínimo para começar a comprar. Qdo passar desse valor, inicia
INITIAL_BUY=54000


e) Adicione esses novos parametros no inicio da app
// .env
const interval = process.env.CRAWLER_INTERVAL
const symbol = process.env.SYMBOL
const accSymbol = process.env.ACC_SYMBOL
const accMinOrder = process.env.ACC_MIN_ORDER
const qtyOrder = process.env.QTY_ORDER
const symDecimal = process.env.SYMBOL_DECIMAL
const profit = process.env.PROFITABILITY
const initialBuy = process.env.INITIAL_BUY


f) Vamos substituir os valores no código pelos do .env

if(sell < 52000){ para
// Se for maior que o valor definido
if(sell >= initialBuy){  ...

const saldo = parseFloat(coins.find(c => c.asset === 'USDT').free) para
const saldo = parseFloat(coins.find(c => c.asset === accSymbol).free)

if(saldo > 10){ para
if(saldo > accMinOrder){
E no else no final
console.log(`Saldo inferior a ${accMinOrder}`, saldo)

const buyOrder = await api.newOrder(symbol, 0.01) para
const buyOrder = await api.newOrder(symbol, qtyOrder)

g) Coloque a parte responsável pela compra dentro de um if 
   para verificar se a compra deu certo antes de executar
if(buyOrder.status === 'FILLED'){
    // Posicionar ordem de venda com o lucro determinado no PROFITABILITY do .env
    const sellPrice = parseFloat(sell * profit).toFixed(8)
    const sellOrder = await api.newOrder(symbol, 0.01, sellPrice, 'SELL', 'LIMIT')
    console.log('SellStatus: ', sellOrder.status, 'id: ', sellOrder.orderId)
    console.log('SellOrder: ', sellOrder)
}

Na linha const sellOrder = await api.newOrder(symbol, 0.01, sellPrice, 'SELL', 'LIMIT')
Troque o 0.01 por qtyOrder
const sellOrder = await api.newOrder(symbol, qtyOrder, sellPrice, 'SELL', 'LIMIT')

Na linha const sellPrice = parseFloat(sell * profit).toFixed(2)
Troque o 2 por symDecimal
const sellPrice = parseFloat(sell * profit).toFixed(symDecimal)

Teste para ver se ainda funciona, senão revise o código :)
npm start

------------------------------


42 - Mais algumas coisas
a) Só posso comprar se tiver uma ordem de venda, então onde está 
if(sell >= initialBuy){ adicione a condição para testar
if(sell && sell >= initialBuy){

Se rolar com alguma moeda do erro MIN_NOTIONAL é porque está 
tentando comprar uma quantidade abaixo do mínimo
Ver em binance.com/en/trade-rule e ajustar a compra em QTY_ORDER


43 - O correto para essa "estratégia tosca" é acrescentar no preço de venda 
     o valor definido no .env em PROFITABILITY
     precoDeCompra * PROFITABILITY
     Só tem um problema. Dependendo do tamanho da compra, pode pegar várias 
     ordens no book de venda até preencher, ex: Quero comprar 0.01 BTC e retorna
     fills: [
      {
        price: '51362.62000000',
        qty: '0.00973500',
        commission: '0.00000000',
        commissionAsset: 'BTC',
        tradeId: 508022
      },
      {
        price: '51362.64000000',
        qty: '0.00026500',
        commission: '0.00000000',
        commissionAsset: 'BTC',
        tradeId: 508023
      }
    ]

    Então o correto é fazer uma média, e multiplicar.
    Mas perceba o parametro qty, que comprou 0.00973500, e depois 0.00026500
    Então precisa ser uma média ponderada, usando a quantidade de peso.

    Pra não alongar mto, eu fiz isso mais detalhado aqui: 
    https://github.com/rramires/javascript/blob/master/07_ESNext/16_media_ponderada.js

    Vamos apenas copiar o final, e colar antes(fora) do setInterval da app

    const avgObj = (array, propValue, propWeight) => {
    const [sum, weightSum] = array.reduce((acc, order) =>{
        let value = parseFloat(order[propValue])
        let weight = parseFloat(order[propWeight])
        acc[0] = acc[0] + value * weight
        acc[1] = acc[1] + weight
        return acc
    }, [0, 0]) 
    return parseFloat(sum / weightSum)
}

Para usar basta chamar
avgObj(buyOrder.fills, 'price', 'qty')

a) Então nessa parte const buyOrder = await api.newOrder(symbol, qtyOrder) vamos adicionar, ficando assim
const buyOrder = await api.newOrder(symbol, qtyOrder)
// pega o preço médio
const avgPrice = avgObj(buyOrder.fills, 'price', 'qty')
console.log('BuyStatus: ', buyOrder.status, 'id: ', buyOrder.orderId, 'Preço médio:', avgPrice.toFixed(symDecimal))

Testando deve imprimir +-
BuyStatus:  FILLED id:  2351081 Preço médio: 55135.27999

b) E na na compra const sellPrice = parseFloat(sell * profit).toFixed(symDecimal) trocar o sell por avgPrice
const sellPrice = parseFloat(avgPrice * profit).toFixed(symDecimal)

E adicione no log o sellPrice também
console.log('SellStatus: ', sellOrder.status, 'id: ', sellOrder.orderId, 'Preço de venda:', sellPrice)

Agora sim, compra e já cria uma ordem de venda, com o profit correto em relação ao preço de compra.

Teste
npm start
// Se deu tudo certo imprime algo similar a 

Symbol:  BTCUSDT
Highest Buy:  55152.39000000
Lowest Sell:  55158.54000000
Posição da carteira:  [
  { asset: 'BTC', free: '1.05000000', locked: '0.03000000' },
  { asset: 'USDT', free: '5672.64106238', locked: '0.00000000' }
]
Meu saldo é de:  5672.64106238
BuyStatus:  FILLED id:  2353921 Preço médio: 55158.54
SellStatus:  NEW id:  2353926 Preço de venda: 57916.47

------------------------------

Segue o código completo da app até aqui

.env
------------------------------

# Informações da API da Binance
API_URL=https://testnet.binance.vision/api 
API_VERSION = v3
API_KEY=Jm0nju9adddWcjyozgD3gjotRZ2zn0nI1KWk3yJxmmwBYVcDHyqXPig2GPfjafKh
SECRET_KEY=ENbk16yCcD9S6gsi9HlUfokwFSN1v3pLZ0TGVQ46akyuQBFszHxP3UhFwEXrcUB2
#
# Intervalo em que são feitas as chamadas em milissegundos 
CRAWLER_INTERVAL=5000
#
# Ver pares de moedas e valores mínimos em binance.com/en/trade-rule
# Par de moedas
SYMBOL=BTCUSDT
# Qual moeda será acumulada. Ex acumular USDT num par BTCUSDT, Acumular BTC, num par BTCLTC
ACC_SYMBOL=USDT
# Saldo mínimo suficiente para fazer uma ordem, EX em USDT são 10 dólares
ACC_MIN_ORDER=10
# Quantidade a ser comprada e posta à venda por vez: EX 0.01BTC
QTY_ORDER=0.01
# Quantidade de casas decimais da moeda que quer vender, Ex BTC são 2
SYMBOL_DECIMAL=2
# Porcentagem adicionada ao valor de venda, ex 1.1 +10%, 1.05 +5%, etc 
PROFITABILITY=1.05
# Valor mínimo para começar a comprar. Qdo passar desse valor, inicia
INITIAL_BUY=54000
------------------------------

index.js
------------------------------

// imports
const api = require('./api')
// .env
const interval = process.env.CRAWLER_INTERVAL
const symbol = process.env.SYMBOL
const accSymbol = process.env.ACC_SYMBOL
const accMinOrder = process.env.ACC_MIN_ORDER
const qtyOrder = process.env.QTY_ORDER
const symDecimal = process.env.SYMBOL_DECIMAL
const profit = process.env.PROFITABILITY
const initialBuy = process.env.INITIAL_BUY

/**
 * Média ponderada
 */
const avgObj = (array, propValue, propWeight) => {
    const [sum, weightSum] = array.reduce((acc, order) =>{
        let value = parseFloat(order[propValue])
        let weight = parseFloat(order[propWeight])
        acc[0] = acc[0] + value * weight
        acc[1] = acc[1] + weight
        return acc
    }, [0, 0]) 
    return parseFloat(sum / weightSum)
}


setInterval(async () => {
    /*
    console.log('Chamou a API :',  await api.time())
    //console.log('ExchangeInfo :',  await api.exchangeInfo())
    console.log('Account Info: ',  await api.accountInfo())
    */

    let buy = 0, sell = 0

    // faz a chamada no book
    const result = await api.depth(symbol)
    console.log('Symbol: ',  symbol)

    // filtra testando se não está vazio
    if(result.bids && result.bids.length){
        console.log('Highest Buy: ',  result.bids[0][0])
        buy = parseFloat(result.bids[0][0])
    }
    if(result.asks && result.asks.length){
        console.log('Lowest Sell: ',  result.asks[0][0])
        sell = parseFloat(result.asks[0][0])
    }

    // faz a chamada na carteira
    const account = await api.accountInfo()
    // filtra para pegar as moedas
    const coins = account.balances.filter(b => symbol.indexOf(b.asset) !== -1)
    console.log('Posição da carteira: ', coins)

    
    // Se for maior que o valor definido
    if(sell && sell >= initialBuy){      
        // Verificando se tenho saldo 
        const saldo = parseFloat(coins.find(c => c.asset === accSymbol).free)
        // Verifica se o saldo é o mínimo possivel para efetuar uma ordem
        if(saldo > accMinOrder){
            //
            console.log('Meu saldo é de: ', saldo)

            // Executa a ordem, comprando 0.01 BTC com USDT por exemplo
            // Não passamos o price, pois é uma ordem a mercado
            // ou seja, o menor preço no momento
            const buyOrder = await api.newOrder(symbol, qtyOrder)
            // pega o preço médio
            const avgPrice = avgObj(buyOrder.fills, 'price', 'qty')
            console.log('BuyStatus: ', buyOrder.status, 'id: ', buyOrder.orderId, 'Preço médio:', avgPrice.toFixed(symDecimal))

            // se conseguiu comprar
            if(buyOrder.status === 'FILLED'){
                // Posicionar ordem de venda com o lucro determinado no PROFITABILITY do .env
                const sellPrice = parseFloat(avgPrice * profit).toFixed(symDecimal)
                // cria a ordem
                const sellOrder = await api.newOrder(symbol, qtyOrder, sellPrice, 'SELL', 'LIMIT')
                console.log('SellStatus: ', sellOrder.status, 'id: ', sellOrder.orderId, 'Preço de venda:', sellPrice)
                // console.log('SellOrder: ', sellOrder)
            }
        }
        else{
            console.log(`Saldo inferior a ${accMinOrder} = `, saldo)
        }
    }
    else{
        console.log('Esperando o mercado sair do lugar...')
    }
    
}, interval)
------------------------------

app.js
------------------------------

// imports
const axios = require('axios')
const querystring = require('querystring')
const crypto = require('crypto')
const apiKey = process.env.API_KEY
const secretKey = process.env.SECRET_KEY
const apiURL = process.env.API_URL
const apiVersion = process.env.API_VERSION

/**
 * Metodo interno que monta e faz as chamadas públicas
 * 
 * @param path - Consulta desejada na API
 * @param data - Dados que serão convertidos no formato querystring
 * @param method GET ou POST
 * @returns json
 */
const publicCall = async (path, data, method = 'GET') => {
    try{
        // monta a query
        const query = data ? `?${querystring.encode(data)}` : ''

        // monta a url
        const url = `${apiURL}/${apiVersion}/${path}${query}`
        //console.log('url: ', url)

        // faz a chamada
        const result = await axios({
            method,
            url
        })
        return result.data
    }
    catch(err){
        console.log(err)
    }
}


/**
 * Metodo interno que monta e faz as chamadas privadas
 * 
 * @param path - Consulta desejada na API
 * @param data - Dados que serão convertidos no formato querystring
 * @param method GET ou POST
 * @returns json
 */
const privateCall = async (path, data = {}, method = 'GET') => {
    try{
        // pega o timestamp
        const timestamp = Date.now()
        // monta o hash/assinatura 
        const signature = crypto.createHmac('sha256', secretKey) // cria a assinatura
                                // incrementa os dados e o timestamp
                                .update(`${querystring.encode({...data, timestamp})}`) 
                                // define o formato de saída
                                .digest('hex')
        //console.log('Signature', signature)
        
        // gera o objeto de dados
        const newData = {...data, timestamp, signature}

        // monta a query
        const query = `?${querystring.encode(newData)}`

        // monta a url
        const url = `${apiURL}/${apiVersion}/${path}${query}`
        //console.log('url: ', url)

        // faz a chamada 
        // 'X-MBX-APIKEY', é um Header específico da Binance que tem que ter a API_KEY
        const result = await axios({
            method,
            url,
            headers: {
                'X-MBX-APIKEY': apiKey
            }
        })
        return result.data
    }
    catch(err){
        console.log(err)
    }
}


/**
 * Metodo de teste, que retora o horario do servidor
 * 
 * @returns json
 */
const time = async () => {
    return publicCall('time')
}


/**
 * Retorna infos do book de um par de moedas (symbol)
 * 
 * @param symbol Par de moedas, ex BTCUSDT, LTCBTC, etc
 * @param limit Quantidade de ordens no book - Minimo 5
 * @returns json
 */
const depth = async (symbol = 'BTCUSDT', limit = 5) => {
    return publicCall('depth', {
        symbol, 
        limit
    })
}


/**
 * Retorna as informações da Exchange
 * 
 * @returns json
 */
const exchangeInfo = async () => {
    return publicCall('exchangeInfo')
}


/**
 * Retorna as informações da Conta
 * 
 * @returns json
 */
const accountInfo = async () => {
    return privateCall('account')
}


/**
 * 
 * @param symbol - Par de moedas, ex BTCUSDT
 * @param quantity - Quantidade
 * @param price - Preço
 * @param side - Qual book, BUY ou SELL
 * @param type - Tipo de ordem, LIMIT, MARKET, STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, TAKE_PROFIT_LIMIT, LIMIT_MAKER
 * @returns json
 */
const newOrder = async (symbol, quantity, price, side = 'BUY', type = 'MARKET') => {
    // monta o objeto de dados
    const data = {symbol, side, type, quantity}
    if(price){
        data.price = price
    }
    if(type === 'LIMIT'){
        data.timeInForce = 'GTC' // got til canceled - Ordem não expira
    }
    return privateCall('order', data, method = 'POST')
}


// exports
module.exports = {
    time,
    depth,
    exchangeInfo,
    accountInfo,
    newOrder
}

------------------------------


44 - Vamos melhorar algumas coisas. 
   - Adicionar um parametro ACC_MIN_BALANCE, para definir o saldo a ser mantido na carteira na moeda a ser acumulada
   - Implementar a compra até o final do saldo, respeitando o saldo mínimo
   - Criar uma variavel para guardar o ATH (valor máximo atingido), e só recomprar a partir dele, menos a porcentagem definida em BUY_BACK

a) Vamos precisar de mais alguns parametros no .env
# Quantidade mínima de saldo que será deixado na carteira
ACC_MIN_BALANCE=2000
# Quantidade mínima possível: EX 0.00001BTC
MIN_ORDER=0.00001
# Porcentagem adicionada ao valor recompra, ex 1.1 -10%, 1.05 -5%, etc 
BUY_BACK=1.05
# Qual moeda será comprada e vendida. (o outro lado do par), ex BTC, no par BTCUSDT
COIN=BTC

b) Adicione os novos parametros no inicio da app
const accMinBalance = process.env.ACC_MIN_BALANCE
const minOrder = process.env.MIN_ORDER
const buyBack = process.env.BUY_BACK

Trocar no .env ACC_SYMBOL=USDT por 
ACC_COIN=USDT 

Procurar e substituir na app, ficando
const accCoin = process.env.ACC_COIN e em
const saldo = parseFloat(coins.find(c => c.asset === accCoin).free)

Adicionar tambem na app
const coin = process.env.COIN

c) Por enquanto comente toda a parte de compra e venda e refatorar as informações iniciais
Crie uma função para formatar a data
/**
 * Data no formato string a partir de um timestamp
 */
const sdtDate = (timestamp) =>{
    const date = new Date(timestamp);
    //
    const year = date.getFullYear();
    const month = ("0" + (date.getMonth() + 1)).slice(-2);
    const day = ("0" + date.getDate()).slice(-2);
    const hours = ("0" + date.getHours()).slice(-2);
    const minutes = ("0" + date.getMinutes()).slice(-2);
    const seconds = ("0" + date.getSeconds()).slice(-2);
    //
    return `${day}/${month}/${year} - ${hours}:${minutes}:${seconds}`
}

Fica assim, por enquanto

//
let buy = 0, sell = 0

// limpa
console.clear()

// pega o horário do servidor
let time = await api.time()

// faz a chamada no book
const result = await api.depth(symbol)
console.log('Book:',  symbol, '- Server Time:', sdtDate(time.serverTime))

// filtra testando se não está vazio
if(result.bids && result.bids.length){
    console.log('Highest Buy:',  result.bids[0][0])
    buy = parseFloat(result.bids[0][0])
}
if(result.asks && result.asks.length){
    console.log('Lowest Sell:',  result.asks[0][0])
    sell = parseFloat(result.asks[0][0])
}
// linha
console.log('----------------------------------------------------------------------')

// faz a chamada na carteira
const account = await api.accountInfo()
// filtra para pegar as moedas
const coins = account.balances.filter(b => symbol.indexOf(b.asset) !== -1)
//console.log('Posição da carteira: ', coins)

// Pegando os saldos na moeda 
const coinFree = parseFloat(coins.find(c => c.asset === coin).free)
const coinLocked = parseFloat(coins.find(c => c.asset === coin).locked)
const coinTotal = coinFree + coinLocked
console.log('Total', `${coin}:`, coinTotal.toFixed(symDecimal), '- Free:', coinFree.toFixed(symDecimal), '- Locked:', coinLocked.toFixed(symDecimal))

// Pegando os saldos na moeda de acumulação
const accFree = parseFloat(coins.find(c => c.asset === accCoin).free)
const accLocked = parseFloat(coins.find(c => c.asset === accCoin).locked)
const accTotal = accFree + accLocked
console.log('Total', `${accCoin}:`, accTotal.toFixed(symDecimal), '- Free:', accFree.toFixed(symDecimal), '- Locked:', accLocked.toFixed(symDecimal))

// Calculando o saldo total da carteira na moeda de acumulação
const totalBalance = parseFloat(accTotal + (coinTotal * sell))
console.log('Total Balance:', totalBalance.toFixed(symDecimal), accCoin)
// linha
console.log('----------------------------------------------------------------------')

Testando deve imprimir
npm start

Book: BTCUSDT - Server Time: 08/10/2021 - 15:40:29
Highest Buy: 54575.63000000
Lowest Sell: 54579.20000000
----------------------------------------------------------------------
Total BTC: 1.05000 - Free: 1.05000 - Locked: 0.00000
Total USDT: 7685.48721 - Free: 7685.48721 - Locked: 0.00000
Total Balance: 64993.64721 USDT
----------------------------------------------------------------------


45 - Continuando a refatoração, lembrando:
   - Adicionar um parametro ACC_MIN_BALANCE, para definir o saldo a ser mantido na carteira na moeda a ser acumulada
   - Implementar a compra até o final do saldo, respeitando o saldo mínimo
   - Criar uma variavel para guardar o ATH (valor máximo atingido), e só recomprar a partir dele, menos a porcentagem definida em BUY_BACK

Segue o código atual:

.env

# Informações da API da Binance
API_URL=https://testnet.binance.vision/api 
API_VERSION = v3
API_KEY=Jm0nju9adddWcjyozgD3gjotRZ2zn0nI1KWk3yJxmmwBYVcDHyqXPig2GPfjafKh
SECRET_KEY=ENbk16yCcD9S6gsi9HlUfokwFSN1v3pLZ0TGVQ46akyuQBFszHxP3UhFwEXrcUB2
#
# Intervalo em que são feitas as chamadas em segundos
CRAWLER_INTERVAL=10
#
# Ver pares de moedas e valores mínimos em binance.com/en/trade-rule
# (olhar a parte gráfica da Binance, mais confiável)
# Par de moedas
SYMBOL=BTCUSDT
# Qual moeda será acumulada. Ex acumular USDT num par BTCUSDT, Acumular BTC, num par BTCLTC
ACC_COIN=USDT
# Quantidade de casas decimais da moeda de acumulação
ACC_DECIMAL=2
# Saldo mínimo suficiente para fazer uma ordem, EX em USDT são 10 dólares
ACC_MIN_ORDER=10
# Quantidade mínima de saldo que será deixado na carteira
ACC_MIN_BALANCE=1000
# Valor mínimo para começar a comprar. Qdo passar desse valor, inicia
INITIAL_BUY=54000
#
# Qual moeda será comprada e vendida. (o outro lado do par), ex BTC, no par BTCUSDT
COIN=BTC
# Quantidade de casas decimais da moeda comprada e vendida
COIN_DECIMAL=5
# Quantidade a ser comprada e posta à venda por vez: EX 0.01BTC
QTY_ORDER=0.01
# Quantidade mínima possível: EX 0.0001BTC
MIN_ORDER=0.0001
# Porcentagem adicionada ao valor de venda, ex 1.1 +10%, 1.05 +5%, etc 
PROFITABILITY=1.05
# Porcentagem adicionada ao valor recompra, ex 0.9 -10%, 0.95 -5%, etc 
BUY_BACK=0.95

------------------------------


index.js

// imports
const api = require('./api')
// .env
const interval = process.env.CRAWLER_INTERVAL
//
const symbol = process.env.SYMBOL
//
const accCoin = process.env.ACC_COIN
const accDecimal = process.env.ACC_DECIMAL
const accMinOrder = process.env.ACC_MIN_ORDER
const accMinBalance = process.env.ACC_MIN_BALANCE
const initialBuy = process.env.INITIAL_BUY
//
const coin = process.env.COIN
const coinDecimal = process.env.COIN_DECIMAL
const qtyOrder = process.env.QTY_ORDER
const minOrder = process.env.MIN_ORDER
const profit = process.env.PROFITABILITY
const buyBack = process.env.BUY_BACK


/**
 * Média ponderada
 */
const avgObj = (array, propValue, propWeight) => {
    const [sum, weightSum] = array.reduce((acc, order) =>{
        let value = parseFloat(order[propValue])
        let weight = parseFloat(order[propWeight])
        acc[0] = acc[0] + value * weight
        acc[1] = acc[1] + weight
        return acc
    }, [0, 0]) 
    return parseFloat(sum / weightSum)
}


/**
 * Data no formato string a partir de um timestamp
 */
const sdtDate = (timestamp) =>{
    const date = new Date(timestamp);
    //
    const year = date.getFullYear();
    const month = ("0" + (date.getMonth() + 1)).slice(-2);
    const day = ("0" + date.getDate()).slice(-2);
    const hours = ("0" + date.getHours()).slice(-2);
    const minutes = ("0" + date.getMinutes()).slice(-2);
    const seconds = ("0" + date.getSeconds()).slice(-2);
    //
    return `${day}/${month}/${year} - ${hours}:${minutes}:${seconds}`
}


// armazena o maior valor de compra
let athWhenBought = 0


setInterval(async () => {
    // limpa
    console.clear()

    // pega o horário do servidor
    let time = await api.time()

    // faz a chamada no book
    const result = await api.depth(symbol)
    console.log('Book:',  symbol, '- Server Time:', sdtDate(time.serverTime))

    let buy = 0, sell = 0
    // filtra testando se não está vazio
    if(result.bids && result.bids.length){
        buy = parseFloat(result.bids[0][0])
        console.log('Highest Buy:',  buy)
    }
    if(result.asks && result.asks.length){
        sell = parseFloat(result.asks[0][0])
        console.log('Lowest Sell:',  sell)
    }
    // linha
    console.log('----------------------------------------------------------------------')

    // faz a chamada na carteira
    const account = await api.accountInfo()
    // filtra para pegar as moedas
    const coins = account.balances.filter(b => symbol.indexOf(b.asset) !== -1)
    //console.log('Posição da carteira: ', coins)

    // Pegando os saldos na moeda 
    const coinFree = parseFloat(coins.find(c => c.asset === coin).free)
    const coinLocked = parseFloat(coins.find(c => c.asset === coin).locked)
    const coinTotal = coinFree + coinLocked
    console.log('Total', `${coin}:`, coinTotal.toFixed(coinDecimal), '- Free:', coinFree.toFixed(coinDecimal), '- Locked:', coinLocked.toFixed(coinDecimal))

    // Pegando os saldos na moeda de acumulação
    const accFree = parseFloat(coins.find(c => c.asset === accCoin).free)
    const accLocked = parseFloat(coins.find(c => c.asset === accCoin).locked)
    const accTotal = accFree + accLocked
    console.log('Total', `${accCoin}:`, accTotal.toFixed(accDecimal), '- Free:', accFree.toFixed(accDecimal), '- Locked:', accLocked.toFixed(accDecimal))

    // Calculando o saldo total da carteira na moeda de acumulação
    const totalBalance = parseFloat(accTotal + (coinTotal * sell))
    console.log('Total Balance:', totalBalance.toFixed(accDecimal), accCoin)
    // linha
    console.log('----------------------------------------------------------------------')

    
    /**
     * Se tiver ordem no book de vendas
     * se for maior que o valor mínimo de entrada, definido no book
     */
    if(sell < 0 && sell <= initialBuy){ 
        console.log('Waiting for the market to reach:', initialBuy)
    }
    else{
        /**
         * Cálculos do tamanho da ordem
         */

        // calcula o valor disponivel para compra
        const accAvailable = accFree - accMinBalance - accMinOrder
        //console.log('accAvailable:', accAvailable)

        // calcula o tamanho da ordem na moeda de acumulo de acordo com o definido em QTY_ORDER
        const buyAccValue = parseFloat(qtyOrder * sell)

        // calcula o tamanho mínimo da ordem possível na moeda de acumulo de acordo com o definido em MIN_ORDER
        const minBuyAccValue = parseFloat(minOrder * sell)

        // valor a ser comprado
        let buyValue = 0

        // Verifica se tem saldo suficiente para comprar o valor inteiro definido em QTY_ORDER
        if(buyAccValue <= accAvailable){
            buyValue = qtyOrder
        }
        // Verifica se tem saldo suficiente para comprar o mínimo definido em MIN_ORDER
        else if(minBuyAccValue <= accAvailable){
            buyValue = parseFloat(accAvailable / sell).toFixed(coinDecimal)
        }
        else{
            console.log('There is not enough balance for a purchase.')
        }
        // console.log('buyValue:', buyValue)

        // se foi validado e definido um valor de compra
        if(buyValue > 0){
            
            /**
             * Faz a compra
             * Não passamos o price, pois é uma ordem a mercado 
             * ou seja, o menor preço no momento
             */ 
            const buyOrder = await api.newOrder(symbol, buyValue)

            // calcula o preço médio da compra
            const avgPrice = avgObj(buyOrder.fills, 'price', 'qty')
            console.log('BuyStatus:', buyOrder.status, '- Id: ', buyOrder.orderId, '- Qty:', buyValue, '- Average price:', avgPrice.toFixed(accDecimal))

            
            // se conseguiu comprar, posicionar ordem de venda com o lucro determinado no PROFITABILITY do .env
            if(buyOrder.status === 'FILLED'){
                // adiciona o percentual de lucro em cima do preço médio
                const sellPrice = parseFloat(avgPrice * profit).toFixed(accDecimal)

                // cria a ordem
                const sellOrder = await api.newOrder(symbol, buyValue, sellPrice, 'SELL', 'LIMIT')
                console.log('SellStatus: ', sellOrder.status, '- Id: ', sellOrder.orderId, '- Qty:', buyValue, '-Sell price:', sellPrice)
                // console.log('SellOrder: ', sellOrder)
            }
        }
    }    
}, interval * 1000)

------------------------------

app.js Não foi mexido

// Com isso conseguimos ir comprando e colocando a venda até chegar nos limites e ficar sem saldo.

Book: BTCUSDT - Server Time: 08/10/2021 - 19:19:38
Highest Buy: 54128.51
Lowest Sell: 54128.52
----------------------------------------------------------------------
Total BTC: 1.21313 - Free: 1.09000 - Locked: 0.12313
Total USDT: 109.80 - Free: 109.80 - Locked: 0.00
Min Balance: 1000.00 - Aprox. Total Balance: 65774.73 USDT
----------------------------------------------------------------------
There is not enough balance for a purchase.

------------------------------


46 - Continuando a refatoração
   OK Adicionar um parametro ACC_MIN_BALANCE, para definir o saldo a ser mantido na carteira na moeda a ser acumulada
   OK Implementar a compra até o final do saldo, respeitando o saldo mínimo
   Falta agora:
   - Criar uma variavel para guardar o ATH (valor máximo atingido), e só recomprar a partir dele, menos a porcentagem definida em BUY_BACK







